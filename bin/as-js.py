#!/usr/bin/python

import datetime
import json
import math
import optparse
from pipes import quote as shell_quote
import re
import shlex
import sys

import shapely.wkb
from shapely.geometry import LineString, MultiLineString, GeometryCollection
import psycopg2

import utils

class AsJSON(object):
  def __init__(self, options, carts):
    self.options = options
    self.carts = carts
    self.db = psycopg2.connect("host=localhost")
    self.m = utils.Map(self.db, options.map)
    
    if options.output:
      self.out = open(options.output, 'w')
    else:
      self.out = sys.stdout
    
    if self.options.simplification_json:
      self.simplification_dict = json.loads(self.options.simplification_json)
    else:
      self.simplification_dict = {}
  
  @staticmethod
  def _extract_cart_name(cart):
    n = re.sub(r".*/", "", cart)
    n = re.sub(r"\.cart$", "", n)
    return n
  
  def _init_carts(self):
    self.interpolators = {
      "_raw": None
    }
    for cart in self.carts:
      cart_name = self._extract_cart_name(cart)
      print >>sys.stderr, "Loading cartogram grid for {cart_name}...".format(cart_name=cart_name)
      self.interpolators[cart_name] = utils.Interpolator(cart, self.m)
  
  def region_paths(self):
    c = self.db.cursor()
    try:
      c.execute("""
        select region.id
             , region.name
             , ST_AsEWKB(ST_Transform(region.the_geom, %(srid)s)) g
        from region
        where region.division_id = %(division_id)s
      """, {
          "srid": self.m.srid,
          "division_id": self.m.division_id
      })
      
      for region_id, region_name, g in c:
        p = shapely.wkb.loads(str(g))
        
        yield region_name, p, self.breakpoints(region_id, region_name)
    
    finally:
      c.close()
  
  def breakpoints(self, region_id, region_name):
    c = self.db.cursor()
    try:
      c.execute("""
        select ST_AsEWKB(
                ST_Transform(
                  ST_Union(
                    CASE GeometryType(x.border)
                      WHEN 'POINT' THEN
                        x.border
                      WHEN 'LINESTRING' THEN
                        ST_Boundary(x.border)
                      WHEN 'MULTILINESTRING' THEN
                        ST_Boundary(ST_LineMerge(x.border))
                    END
                  ),
                  %(srid)s
                )
              ) breakpoints
        from (
          select ST_Intersection(ST_Boundary(target.the_geom), ST_Boundary(neighbour.the_geom)) border
          from region target
             , region neighbour
          where target.id = %(region_id)s
          and ST_Touches(target.the_geom, neighbour.the_geom)
          and neighbour.division_id = %(division_id)s
        ) x
      """, {
        "srid": self.m.srid,
        "division_id": self.m.division_id,
        "region_id": region_id,
      })
      
      row = c.fetchone()
      if row[0] is None:
        return set()
      
      try:
        multipoint = shapely.wkb.loads(str(row[0]))
      except Exception, exception:
        print >>sys.stderr, "Failed to load checkpoints ({checkpoints}) for {region_name}: {exception}".format(
          region_name=region_name,
          exception=repr(exception),
          checkpoints=repr(str(row[0]))
        )
        return set()
      
      return set((
        (point.x, point.y) for point in multipoint
      ))
      
    except Exception, exception:
      print >>sys.stderr, "Database error loading checkpoints for {region_name}: {exception}".format(
          region_name=region_name,
          exception=repr(exception),
        )
      return set()
    
    finally:
      c.close()
  
  def print_region_paths(self):
    print >>self.out, "// This file is auto-generated. Please do not edit."
    print >>self.out, "// Generated at {t} UTC.".format(t=str(datetime.datetime.utcnow()))
    print >>self.out, "// Generated by {c}".format(c=" ".join(map(shell_quote, sys.argv)))
    print >>self.out
    
    self._init_carts()
    
    empty_object_json = json.dumps( dict(( (k, {}) for k in self.interpolators.keys() )) )
    print >>self.out, "var %s = %s;" % (self.options.data_var, empty_object_json,)
    if self.options.include_segments:
      print >>self.out, "var segments = %s;" % (empty_object_json,)
    
    for region_name, p, breakpoints in self.region_paths():
      print >>sys.stderr, "Extracting paths for {region_name}...".format(region_name=region_name)
      for k, path in self.multipolygon_as_svg(p, breakpoints, region_name).items():
        if self.options.include_segments:
          self.segments = []
        
        print >>self.out, "{data_var}[{k}][{region_name}] = {path};".format(
          data_var=self.options.data_var,
          k=json.dumps(k),
          region_name=json.dumps(region_name),
          path=json.dumps(path),
        )
        
        if self.options.include_segments and k == "_raw":
          print "segments[\"%s\"] = %r;" % (region_name, self.segments)
    
  
  def _transform(self, x, y):
    if not self.options.output_grid:
      return x, -y
    return (
      (x - self.m.x_min) * self.options.output_grid_width / (self.m.x_max - self.m.x_min),
      self.options.output_grid_height - (y - self.m.y_min) * self.options.output_grid_height / (self.m.y_max - self.m.y_min),
    )

  def _segments(self, coords, breakpoints):
    segments = [[]]
    for coord in coords:
      segments[-1].append(coord)
      if coord in breakpoints:
        segments.append([coord])
    
    if len(segments) > 1:
      # Join the first and last segments
      segments[0] = segments.pop() + segments[0]
    
    if self.options.include_segments:
      for segment in segments:
        self.segments.append([ list(self._transform(x, y)) for x, y in segment ])
    
    return segments
  
  def _segment_length(self, segment):
    return sum([
      math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1))
      for (x1, y1), (x2, y2) in zip(segment, segment[1:])
    ])
  
  def _max_stretch(self, segment):
    l = self._segment_length(segment)
    if l == 0:
      return 1
    
    max_stretch = max([
      self._segment_length([ interpolator(x, y) for (x, y) in segment ])
      for interpolator in self.interpolators.values() if interpolator
    ])
    
    if max_stretch > l:
      return max_stretch / l
    else:
      return 1
  
  def _simplify(self, coords, breakpoints, region_name):
    simplification = self.simplification_dict.get(region_name, self.options.simplification)
    
    prev = None
    for segment in self._segments(coords, breakpoints):
      ls = LineString(segment)
      ls = ls.simplify(tolerance=simplification / self._max_stretch(segment), preserve_topology=False)
      
      for coord in ls.coords:
        if coord != prev:
          yield coord
        prev = coord
  
  def polygon_ring_as_svg(self, ring, breakpoints, path_arrs, region_name):
    coords = list(self._simplify(ring.coords, breakpoints, region_name))
    for k, path_arr in path_arrs.items():
      path_arr.append("M")
      first = True
      for x, y in coords:
        if self.interpolators.get(k):
          x, y = self.interpolators[k](x, y)
        x, y = self._transform(x, y)
        path_arr.append("%.0f" % x)
        path_arr.append("%.0f" % y)
        if first:
          path_arr.append("L")
          first = False
      
      if path_arr[-1] == "L":
        # The path contains only one point, so skip it
        path_arr[-4:] = []
        return
      
      path_arr[-2:] = ["Z"] # The last point is presumably equal to the first
      
      if path_arr[-2] == "L":
        # The path contains only one point, so skip it
        path_arr[-5:] = []
        return

  def multipolygon_as_svg(self, multipolygon, breakpoints, region_name):
    path_arrs = dict((
      (k, []) for k in self.interpolators.keys()
    ))
    for g in multipolygon.geoms:
      self.polygon_ring_as_svg(g.exterior, breakpoints, path_arrs, region_name)
      for interior in g.interiors:
        self.polygon_ring_as_svg(interior, breakpoints, path_arrs, region_name)
  
    return dict((
      (k, " ".join(path_arr))
      for k, path_arr in path_arrs.items()
    ))
  
  def print_json(self):
    self.print_region_paths()

def main():
  global options
  parser = optparse.OptionParser()
  parser.add_option("", "--map",
                    action="store",
                    help="the name of the map to use")
  
  parser.add_option("", "--output-grid",
                    action="store",
                    help="the output grid, in the form <width>x<height>")
  
  parser.add_option("", "--simplification",
                    action="store", default=20000, type="int",
                    help="how much to simplify the paths (default %default)")
  parser.add_option("", "--simplification-json",
                    action="store",
                    help="A JSON-encoded dict of region name => simplification")
  
  parser.add_option("", "--data-var",
                    action="store",
                    default="data",
                    help="name of variable to use for the path data (default %default)")
  
  parser.add_option("", "--include-segments",
                    action="store_true",
                    help="include segments in the output. Useful for debugging")
  parser.add_option("-o", "--output",
                    action="store",
                    help="the name of the output file (defaults to stdout)")
  
  (options, carts) = parser.parse_args()
  
  if not options.map:
    parser.error("Missing option --map")
  
  if options.output_grid:
    mo = re.match(r"^(\d+)x(\d+)$", options.output_grid)
    if mo is None:
      parser.error("Unrecognised value for --output-grid: " + options.output_grid)
    setattr(options, "output_grid_width", int(mo.group(1)))
    setattr(options, "output_grid_height", int(mo.group(2)))
  
  as_json = AsJSON(options=options, carts=carts)
  as_json.print_json()

main()
